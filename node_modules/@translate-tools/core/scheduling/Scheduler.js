"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Scheduler = void 0;
var _Semaphore = require("../utils/Semaphore");
var __assign = void 0 && (void 0).__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
var __values = void 0 && (void 0).__values || function (o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
    m = s && o[s],
    i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
/**
 * Module for scheduling and optimization of translate a text streams
 *
 * - It can union many translate requests to one
 * - You can group any requests by context
 * - It's configurable. You can set retry limit and edge for direct translate
 */
var Scheduler = exports.Scheduler = /** @class */function () {
  function Scheduler(translator, config) {
    var _this = this;
    this.config = {
      translateRetryAttemptLimit: 2,
      isAllowDirectTranslateBadChunks: true,
      directTranslateLength: null,
      translatePoolDelay: 300,
      chunkSizeForInstantTranslate: null,
      taskBatchHandleDelay: null
    };
    this.contextCounter = 0;
    this.taskContainersStorage = new Set();
    this.timersMap = new Map();
    /**
     * Tasks queue with items sorted by priority
     * It must be handled from end to start
     */
    this.translateQueue = [];
    /**
     * Return first item from queue and delete it from queue
     * Items is sorted by priority
     */
    this.getItemFromTranslateQueue = function () {
      var _a;
      return {
        done: _this.translateQueue.length === 0,
        value: (_a = _this.translateQueue.pop()) !== null && _a !== void 0 ? _a : null
      };
    };
    this.workerState = false;
    this.translator = translator;
    if (config !== undefined) {
      for (var key in config) {
        this.config[key] = config[key];
      }
    }
    this.semafor = new _Semaphore.Semaphore({
      timeout: translator.getRequestsTimeout()
    });
  }
  Scheduler.prototype.translate = function (text, from, to, options) {
    return __awaiter(this, void 0, void 0, function () {
      var _a, _b, context, _c, priority, _d, directTranslateForThisRequest;
      return __generator(this, function (_e) {
        _a = options !== undefined ? options : {}, _b = _a.context, context = _b === void 0 ? '' : _b, _c = _a.priority, priority = _c === void 0 ? 0 : _c, _d = _a.directTranslate, directTranslateForThisRequest = _d === void 0 ? false : _d;
        if (this.translator.checkLimitExceeding(text) <= 0) {
          // Direct translate
          if (directTranslateForThisRequest || this.config.directTranslateLength !== null && text.length >= this.config.directTranslateLength) {
            return [2 /*return*/, this.directTranslate(text, from, to)];
          } else {
            return [2 /*return*/, this.makeTask({
              text: text,
              from: from,
              to: to,
              context: context,
              priority: priority
            })];
          }
        } else {
          // Split text by words and translate
          return [2 /*return*/, this.splitAndTranslate(text, from, to, context, priority)];
        }
        return [2 /*return*/];
      });
    });
  };
  Scheduler.prototype.directTranslate = function (text, from, to) {
    return __awaiter(this, void 0, void 0, function () {
      var free;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            return [4 /*yield*/, this.semafor.take()];
          case 1:
            free = _a.sent();
            return [2 /*return*/, this.translator.translate(text, from, to).finally(free)];
        }
      });
    });
  };
  Scheduler.prototype.splitAndTranslate = function (text, from, to, context, priority) {
    var e_1, _a;
    var _this = this;
    var splittedText = [];
    var charsetIndexes = [];
    var wordsBuffer = '';
    try {
      for (var _b = __values(text.matchAll(/([^\s]+)(\s*)/g)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var textMatch = _c.value;
        var newPart = textMatch[0];
        var newBuffer = wordsBuffer + newPart;
        // Add word to buffer if can
        if (this.translator.checkLimitExceeding(newBuffer) <= 0) {
          wordsBuffer = newBuffer;
          continue;
        }
        // Write and clear buffer if not empthy
        if (wordsBuffer.length > 0) {
          splittedText.push(wordsBuffer);
          wordsBuffer = '';
        }
        // Handle new part
        if (this.translator.checkLimitExceeding(newPart) <= 0) {
          // Add to buffer
          wordsBuffer += newPart;
          continue;
        } else {
          // Slice by chars
          var charsBuffer = newPart;
          while (charsBuffer.length > 0) {
            var extraChars = this.translator.checkLimitExceeding(charsBuffer);
            if (extraChars > 0) {
              var offset = charsBuffer.length - extraChars;
              // Write slice and remainder
              splittedText.push(charsBuffer.slice(0, offset));
              charsBuffer = charsBuffer.slice(offset);
              charsetIndexes.push(splittedText.length - 1);
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    var ctxPrefix = context.length > 0 ? context + ';' : '';
    return Promise.all(splittedText.map(function (text, index) {
      return charsetIndexes.indexOf(index) !== -1 ? text : _this.makeTask({
        text: text,
        from: from,
        to: to,
        context: ctxPrefix + "text#".concat(_this.contextCounter++),
        priority: priority
      });
    })).then(function (translatedParts) {
      return translatedParts.join('');
    });
  };
  Scheduler.prototype.makeTask = function (_a) {
    var _this = this;
    var text = _a.text,
      from = _a.from,
      to = _a.to,
      priority = _a.priority,
      _b = _a.context,
      context = _b === void 0 ? '' : _b;
    return new Promise(function (resolve, reject) {
      _this.addToTaskContainer({
        text: text,
        from: from,
        to: to,
        context: context,
        priority: priority,
        resolve: resolve,
        reject: reject
      });
    });
  };
  Scheduler.prototype.addToTaskContainer = function (params) {
    var e_2, _a;
    var text = params.text,
      from = params.from,
      to = params.to,
      _b = params.attempt,
      attempt = _b === void 0 ? 0 : _b,
      _c = params.context,
      context = _c === void 0 ? '' : _c,
      priority = params.priority,
      resolve = params.resolve,
      reject = params.reject;
    // create task
    var task = {
      text: text,
      from: from,
      to: to,
      attempt: attempt,
      resolve: resolve,
      reject: reject
    };
    var container = null;
    var _loop_1 = function (taskContainer) {
      // Skip containers with not equal parameters
      if (['from', 'to', 'context', 'priority'].some(function (key) {
        return params[key] !== taskContainer[key];
      })) return "continue";
      // Lightweight check to overflow
      // NOTE: Do strict check here if you need comply a limit contract
      if (this_1.translator.getLengthLimit() >= taskContainer.length + task.text.length) {
        taskContainer.tasks.push(task);
        taskContainer.length += task.text.length;
        container = taskContainer;
      }
    };
    var this_1 = this;
    try {
      // try add to exists container
      for (var _d = __values(this.taskContainersStorage), _e = _d.next(); !_e.done; _e = _d.next()) {
        var taskContainer = _e.value;
        _loop_1(taskContainer);
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
    // make container
    if (container === null) {
      var newTaskContainer = {
        context: context,
        priority: priority,
        from: from,
        to: to,
        tasks: [task],
        length: task.text.length
      };
      this.taskContainersStorage.add(newTaskContainer);
      container = newTaskContainer;
    }
    if (this.config.chunkSizeForInstantTranslate !== null && container.length >= this.config.chunkSizeForInstantTranslate) {
      this.addToTranslateQueue(container);
    } else {
      this.updateDelayForAddToTranslateQueue(container);
    }
  };
  Scheduler.prototype.updateDelayForAddToTranslateQueue = function (taskContainer) {
    var _this = this;
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
    }
    this.timersMap.set(taskContainer, globalThis.setTimeout(function () {
      _this.addToTranslateQueue(taskContainer);
    }, this.config.translatePoolDelay));
  };
  Scheduler.prototype.addToTranslateQueue = function (taskContainer) {
    // Flush timer
    if (this.timersMap.has(taskContainer)) {
      // Due to expectation run on one platform, timer objects will same always
      globalThis.clearTimeout(this.timersMap.get(taskContainer));
      this.timersMap.delete(taskContainer);
    }
    this.taskContainersStorage.delete(taskContainer);
    // Resort queue by priority each time to keep consistency
    this.translateQueue = this.translateQueue.concat(taskContainer).sort(function (a, b) {
      return a.priority - b.priority;
    });
    if (!this.workerState) {
      this.runWorker();
    }
  };
  Scheduler.prototype.runWorker = function () {
    return __awaiter(this, void 0, void 0, function () {
      var firstIteration, _loop_2, this_2, state_1;
      var _this = this;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            this.workerState = true;
            firstIteration = true;
            _loop_2 = function () {
              var workerHandleDelay, iterate, taskContainer, free, textArray;
              return __generator(this, function (_b) {
                switch (_b.label) {
                  case 0:
                    workerHandleDelay = this_2.config.taskBatchHandleDelay;
                    if (!(workerHandleDelay && firstIteration)) return [3 /*break*/, 2];
                    return [4 /*yield*/, new Promise(function (res) {
                      return setTimeout(res, workerHandleDelay);
                    })];
                  case 1:
                    _b.sent();
                    _b.label = 2;
                  case 2:
                    firstIteration = false;
                    iterate = this_2.getItemFromTranslateQueue();
                    // Skip when queue empty
                    if (iterate.done || iterate.value === null) return [2 /*return*/, "break"];
                    taskContainer = iterate.value;
                    return [4 /*yield*/, this_2.semafor.take()];
                  case 3:
                    free = _b.sent();
                    textArray = taskContainer.tasks.map(function (i) {
                      return i.text;
                    });
                    return [4 /*yield*/, this_2.translator.translateBatch(textArray, taskContainer.from, taskContainer.to).then(function (result) {
                      for (var index in taskContainer.tasks) {
                        var task = taskContainer.tasks[index];
                        var translatedText = result[index];
                        if (translatedText !== null) {
                          task.resolve(translatedText);
                        } else {
                          _this.taskErrorHandler(task, new Error("Translator module can't translate this"), taskContainer.context, taskContainer.priority);
                        }
                      }
                    }).catch(function (reason) {
                      var e_3, _a;
                      console.error(reason);
                      try {
                        for (var _b = (e_3 = void 0, __values(taskContainer.tasks)), _c = _b.next(); !_c.done; _c = _b.next()) {
                          var task = _c.value;
                          _this.taskErrorHandler(task, reason, taskContainer.context, taskContainer.priority);
                        }
                      } catch (e_3_1) {
                        e_3 = {
                          error: e_3_1
                        };
                      } finally {
                        try {
                          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        } finally {
                          if (e_3) throw e_3.error;
                        }
                      }
                    }).finally(free)];
                  case 4:
                    _b.sent();
                    return [2 /*return*/];
                }
              });
            };
            this_2 = this;
            _a.label = 1;
          case 1:
            if (!true) return [3 /*break*/, 3];
            return [5 /*yield**/, _loop_2()];
          case 2:
            state_1 = _a.sent();
            if (state_1 === "break") return [3 /*break*/, 3];
            return [3 /*break*/, 1];
          case 3:
            this.workerState = false;
            return [2 /*return*/];
        }
      });
    });
  };
  Scheduler.prototype.taskErrorHandler = function (task, error, context, priority) {
    if (task.attempt >= this.config.translateRetryAttemptLimit) {
      if (this.config.isAllowDirectTranslateBadChunks) {
        var text = task.text,
          from = task.from,
          to = task.to,
          resolve = task.resolve,
          reject = task.reject;
        this.directTranslate(text, from, to).then(resolve, reject);
      } else {
        task.reject(error);
      }
    } else {
      this.addToTaskContainer(__assign(__assign({}, task), {
        attempt: task.attempt + 1,
        context: context,
        priority: priority
      }));
    }
  };
  return Scheduler;
}();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZWR1bGluZy9TY2hlZHVsZXIuanMiLCJuYW1lcyI6WyJfU2VtYXBob3JlIiwicmVxdWlyZSIsIlNjaGVkdWxlciIsImV4cG9ydHMiLCJ0cmFuc2xhdG9yIiwiY29uZmlnIiwiX3RoaXMiLCJ0cmFuc2xhdGVSZXRyeUF0dGVtcHRMaW1pdCIsImlzQWxsb3dEaXJlY3RUcmFuc2xhdGVCYWRDaHVua3MiLCJkaXJlY3RUcmFuc2xhdGVMZW5ndGgiLCJ0cmFuc2xhdGVQb29sRGVsYXkiLCJjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlIiwidGFza0JhdGNoSGFuZGxlRGVsYXkiLCJjb250ZXh0Q291bnRlciIsInRhc2tDb250YWluZXJzU3RvcmFnZSIsIlNldCIsInRpbWVyc01hcCIsIk1hcCIsInRyYW5zbGF0ZVF1ZXVlIiwiZ2V0SXRlbUZyb21UcmFuc2xhdGVRdWV1ZSIsImRvbmUiLCJsZW5ndGgiLCJ2YWx1ZSIsIl9hIiwicG9wIiwid29ya2VyU3RhdGUiLCJ1bmRlZmluZWQiLCJrZXkiLCJzZW1hZm9yIiwiU2VtYXBob3JlIiwidGltZW91dCIsImdldFJlcXVlc3RzVGltZW91dCIsInByb3RvdHlwZSIsInRyYW5zbGF0ZSIsInRleHQiLCJmcm9tIiwidG8iLCJvcHRpb25zIiwiX2IiLCJjb250ZXh0IiwiX2MiLCJwcmlvcml0eSIsIl9kIiwiZGlyZWN0VHJhbnNsYXRlIiwiZGlyZWN0VHJhbnNsYXRlRm9yVGhpc1JlcXVlc3QiLCJjaGVja0xpbWl0RXhjZWVkaW5nIiwibWFrZVRhc2siLCJzcGxpdEFuZFRyYW5zbGF0ZSIsInRha2UiLCJmcmVlIiwic2VudCIsImZpbmFsbHkiLCJzcGxpdHRlZFRleHQiLCJjaGFyc2V0SW5kZXhlcyIsIndvcmRzQnVmZmVyIiwiX192YWx1ZXMiLCJtYXRjaEFsbCIsIm5leHQiLCJ0ZXh0TWF0Y2giLCJuZXdQYXJ0IiwibmV3QnVmZmVyIiwicHVzaCIsImNoYXJzQnVmZmVyIiwiZXh0cmFDaGFycyIsIm9mZnNldCIsInNsaWNlIiwiY3R4UHJlZml4IiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImluZGV4IiwiaW5kZXhPZiIsImNvbmNhdCIsInRoZW4iLCJ0cmFuc2xhdGVkUGFydHMiLCJqb2luIiwicmVzb2x2ZSIsInJlamVjdCIsImFkZFRvVGFza0NvbnRhaW5lciIsInBhcmFtcyIsImF0dGVtcHQiLCJ0YXNrIiwiY29udGFpbmVyIiwidGFza0NvbnRhaW5lciIsInNvbWUiLCJ0aGlzXzEiLCJnZXRMZW5ndGhMaW1pdCIsInRhc2tzIiwiX2UiLCJuZXdUYXNrQ29udGFpbmVyIiwiYWRkIiwiYWRkVG9UcmFuc2xhdGVRdWV1ZSIsInVwZGF0ZURlbGF5Rm9yQWRkVG9UcmFuc2xhdGVRdWV1ZSIsImhhcyIsImdsb2JhbFRoaXMiLCJjbGVhclRpbWVvdXQiLCJnZXQiLCJzZXQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwic29ydCIsImEiLCJiIiwicnVuV29ya2VyIiwiZmlyc3RJdGVyYXRpb24iLCJ3b3JrZXJIYW5kbGVEZWxheSIsInRoaXNfMiIsInJlcyIsIml0ZXJhdGUiLCJ0ZXh0QXJyYXkiLCJpIiwidHJhbnNsYXRlQmF0Y2giLCJyZXN1bHQiLCJ0cmFuc2xhdGVkVGV4dCIsInRhc2tFcnJvckhhbmRsZXIiLCJFcnJvciIsImNhdGNoIiwicmVhc29uIiwiY29uc29sZSIsImVycm9yIiwiZV8zIiwiX19hc3NpZ24iXSwic291cmNlcyI6WyJzY2hlZHVsaW5nL1NjaGVkdWxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJU2NoZWR1bGVyVHJhbnNsYXRlT3B0aW9ucywgSVNjaGVkdWxlciB9IGZyb20gJy4nO1xuaW1wb3J0IHtcblx0bGFuZ0NvZGUsXG5cdGxhbmdDb2RlV2l0aEF1dG8sXG5cdFRyYW5zbGF0b3JJbnN0YW5jZU1lbWJlcnMsXG59IGZyb20gJy4uL3RyYW5zbGF0b3JzL1RyYW5zbGF0b3InO1xuaW1wb3J0IHsgU2VtYXBob3JlIH0gZnJvbSAnLi4vdXRpbHMvU2VtYXBob3JlJztcblxuaW50ZXJmYWNlIFNjaGVkdWxlckNvbmZpZyB7XG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgZm9yIHJldHJ5IHJlcXVlc3Rcblx0ICovXG5cdHRyYW5zbGF0ZVJldHJ5QXR0ZW1wdExpbWl0PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBJZiB0cnVlIC0gcmVqZWN0ZWQgcmVxdWVzdHMgd2lsbCB1c2UgZGlyZWN0IHRyYW5zbGF0ZVxuXHQgKi9cblx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rcz86IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIExlbmd0aCBvZiBzdHJpbmcgZm9yIGRpcmVjdCB0cmFuc2xhdGUuXG5cdCAqXG5cdCAqIG51bGwgZm9yIGRpc2FibGUgdGhlIGNvbmRpdGlvblxuXHQgKi9cblx0ZGlyZWN0VHJhbnNsYXRlTGVuZ3RoPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogRGVsYXkgZm9yIHRyYW5zbGF0ZSBhIGNodW5rLiBUaGUgYmlnZ2VyIHRoZSBtb3JlIHJlcXVlc3RzIHdpbGwgY29sbGVjdFxuXHQgKi9cblx0dHJhbnNsYXRlUG9vbERlbGF5PzogbnVtYmVyO1xuXG5cdC8qKlxuXHQgKiBXaGVuIGNodW5rIGNvbGxlY3QgdGhpcyBzaXplLCBpdCdzIHdpbGwgYmUgaW5zdGFudCBhZGQgdG8gYSB0cmFuc2xhdGUgcXVldWVcblx0ICpcblx0ICogbnVsbCBmb3IgZGlzYWJsZSB0aGUgY29uZGl0aW9uXG5cdCAqL1xuXHRjaHVua1NpemVGb3JJbnN0YW50VHJhbnNsYXRlPzogbnVtYmVyIHwgbnVsbDtcblxuXHQvKipcblx0ICogUGF1c2UgYmV0d2VlbiBoYW5kbGUgdGFzayBiYXRjaGVzXG5cdCAqXG5cdCAqIEl0IG1heSBiZSB1c2VmdWwgdG8gYXdhaXQgYWNjdW11bGF0aW5nIGEgdGFzayBiYXRjaGVzIGluIHF1ZXVlIHRvIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciBhbmQgZG9uJ3QgdHJhbnNsYXRlIGZpcnN0IHRhc2sgYmF0Y2ggaW1tZWRpYXRlbHlcblx0ICpcblx0ICogV0FSTklORzogdGhpcyBvcHRpb24gbXVzdCBiZSB1c2VkIG9ubHkgZm9yIGNvbnNpZGVyIHByaW9yaXR5IGJldHRlciEgU2V0IHNtYWxsIHZhbHVlIGFsd2F5cyAoMTAtNTBtcylcblx0ICpcblx0ICogV2hlbiB0aGlzIG9wdGlvbiBpcyBkaXNhYmxlZCAoYnkgZGVmYXVsdCkgYW5kIHlvdSBjYWxsIHRyYW5zbGF0ZSBtZXRob2QgZm9yIHRleHRzIHdpdGggcHJpb3JpdHkgMSBhbmQgdGhlbiBpbW1lZGlhdGVseSBmb3IgdGV4dCB3aXRoIHByaW9yaXR5IDIsIGZpcnN0IHJlcXVlc3Qgd2lsbCBoYXZlIGxlc3MgZGVsYXkgZm9yIHRyYW5zbGF0ZSBhbmQgd2lsbCB0cmFuc2xhdGUgZmlyc3QsIGV2ZW4gd2l0aCBsb3dlciBwcmlvcml0eSwgYmVjYXVzZSB3b3JrZXIgd2lsbCB0cmFuc2xhdGUgZmlyc3QgdGFzayBpbW1lZGlhdGVseSBhZnRlciBkZWxheSBkZWZpbmVkIGJ5IG9wdGlvbiBgdHJhbnNsYXRlUG9vbERlbGF5YFxuXHQgKi9cblx0dGFza0JhdGNoSGFuZGxlRGVsYXk/OiBudWxsIHwgbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgVGFza0NvbnN0cnVjdG9yIHtcblx0dGV4dDogc3RyaW5nO1xuXHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvO1xuXHR0bzogbGFuZ0NvZGU7XG5cblx0LyoqXG5cdCAqIFRvIGNvbWJpbmUgdGFza3MgYnkgdW5pcXVlIGtleVxuXHQgKi9cblx0Y29udGV4dD86IHN0cmluZztcblxuXHQvKipcblx0ICogVG8gY29tYmluZSBhbmQgc29ydCB0YXNrcyBieSBwcmlvcml0eVxuXHQgKi9cblx0cHJpb3JpdHk6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFRhc2tDb25zdHJ1Y3RvckludGVybmFsIGV4dGVuZHMgVGFza0NvbnN0cnVjdG9yIHtcblx0LyoqXG5cdCAqIEN1cnJlbnQgcmV0cnkgYXR0ZW1wdFxuXHQgKi9cblx0YXR0ZW1wdD86IG51bWJlcjtcblxuXHRyZXNvbHZlOiAodmFsdWU6IHN0cmluZyB8IFByb21pc2VMaWtlPHN0cmluZz4pID0+IHZvaWQ7XG5cdHJlamVjdDogKHJlYXNvbj86IGFueSkgPT4gdm9pZDtcbn1cblxuaW50ZXJmYWNlIFRhc2sge1xuXHR0ZXh0OiBzdHJpbmc7XG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblxuXHQvKipcblx0ICogQ3VycmVudCByZXRyeSBhdHRlbXB0XG5cdCAqL1xuXHRhdHRlbXB0OiBudW1iZXI7XG5cblx0cmVzb2x2ZTogKHZhbHVlOiBzdHJpbmcgfCBQcm9taXNlTGlrZTxzdHJpbmc+KSA9PiB2b2lkO1xuXHRyZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG59XG5cbmludGVyZmFjZSBUYXNrQ29udGFpbmVyIHtcblx0LyoqXG5cdCAqIEZvciBjb21iaW5lIHRhc2tzIGJ5IHVuaXF1ZSBrZXlcblx0ICovXG5cdGNvbnRleHQ6IHN0cmluZztcblxuXHRwcmlvcml0eTogbnVtYmVyO1xuXG5cdGZyb206IGxhbmdDb2RlV2l0aEF1dG87XG5cdHRvOiBsYW5nQ29kZTtcblx0dGFza3M6IFRhc2tbXTtcblxuXHQvKipcblx0ICogVG90YWwgbGVuZ3RoIG9mIHRleHQgZnJvbSBhbGwgdGFza3Ncblx0ICovXG5cdGxlbmd0aDogbnVtYmVyO1xufVxuXG50eXBlIEl0ZXJhdG9yU3RlcDxUPiA9IHtcblx0ZG9uZTogYm9vbGVhbjtcblx0dmFsdWU6IFQgfCBudWxsO1xufTtcblxuLyoqXG4gKiBNb2R1bGUgZm9yIHNjaGVkdWxpbmcgYW5kIG9wdGltaXphdGlvbiBvZiB0cmFuc2xhdGUgYSB0ZXh0IHN0cmVhbXNcbiAqXG4gKiAtIEl0IGNhbiB1bmlvbiBtYW55IHRyYW5zbGF0ZSByZXF1ZXN0cyB0byBvbmVcbiAqIC0gWW91IGNhbiBncm91cCBhbnkgcmVxdWVzdHMgYnkgY29udGV4dFxuICogLSBJdCdzIGNvbmZpZ3VyYWJsZS4gWW91IGNhbiBzZXQgcmV0cnkgbGltaXQgYW5kIGVkZ2UgZm9yIGRpcmVjdCB0cmFuc2xhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBpbXBsZW1lbnRzIElTY2hlZHVsZXIge1xuXHRwcml2YXRlIHJlYWRvbmx5IHNlbWFmb3I7XG5cdHByaXZhdGUgcmVhZG9ubHkgdHJhbnNsYXRvcjtcblx0cHJpdmF0ZSByZWFkb25seSBjb25maWc6IFJlcXVpcmVkPFNjaGVkdWxlckNvbmZpZz4gPSB7XG5cdFx0dHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQ6IDIsXG5cdFx0aXNBbGxvd0RpcmVjdFRyYW5zbGF0ZUJhZENodW5rczogdHJ1ZSxcblx0XHRkaXJlY3RUcmFuc2xhdGVMZW5ndGg6IG51bGwsXG5cdFx0dHJhbnNsYXRlUG9vbERlbGF5OiAzMDAsXG5cdFx0Y2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZTogbnVsbCxcblx0XHR0YXNrQmF0Y2hIYW5kbGVEZWxheTogbnVsbCxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcih0cmFuc2xhdG9yOiBUcmFuc2xhdG9ySW5zdGFuY2VNZW1iZXJzLCBjb25maWc/OiBTY2hlZHVsZXJDb25maWcpIHtcblx0XHR0aGlzLnRyYW5zbGF0b3IgPSB0cmFuc2xhdG9yO1xuXG5cdFx0aWYgKGNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcblx0XHRcdFx0KHRoaXMuY29uZmlnIGFzIGFueSlba2V5XSA9IChjb25maWcgYXMgYW55KVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuc2VtYWZvciA9IG5ldyBTZW1hcGhvcmUoeyB0aW1lb3V0OiB0cmFuc2xhdG9yLmdldFJlcXVlc3RzVGltZW91dCgpIH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjb250ZXh0Q291bnRlciA9IDA7XG5cdHB1YmxpYyBhc3luYyB0cmFuc2xhdGUoXG5cdFx0dGV4dDogc3RyaW5nLFxuXHRcdGZyb206IGxhbmdDb2RlV2l0aEF1dG8sXG5cdFx0dG86IGxhbmdDb2RlLFxuXHRcdG9wdGlvbnM/OiBJU2NoZWR1bGVyVHJhbnNsYXRlT3B0aW9ucyxcblx0KSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHkgPSAwLFxuXHRcdFx0ZGlyZWN0VHJhbnNsYXRlOiBkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCA9IGZhbHNlLFxuXHRcdH0gPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zIDoge307XG5cblx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcodGV4dCkgPD0gMCkge1xuXHRcdFx0Ly8gRGlyZWN0IHRyYW5zbGF0ZVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXJlY3RUcmFuc2xhdGVGb3JUaGlzUmVxdWVzdCB8fFxuXHRcdFx0XHQodGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoICE9PSBudWxsICYmXG5cdFx0XHRcdFx0dGV4dC5sZW5ndGggPj0gdGhpcy5jb25maWcuZGlyZWN0VHJhbnNsYXRlTGVuZ3RoKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmRpcmVjdFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0byk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5tYWtlVGFzayh7IHRleHQ6IHRleHQsIGZyb20sIHRvLCBjb250ZXh0LCBwcmlvcml0eSB9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gU3BsaXQgdGV4dCBieSB3b3JkcyBhbmQgdHJhbnNsYXRlXG5cdFx0XHRyZXR1cm4gdGhpcy5zcGxpdEFuZFRyYW5zbGF0ZSh0ZXh0LCBmcm9tLCB0bywgY29udGV4dCwgcHJpb3JpdHkpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgYXN5bmMgZGlyZWN0VHJhbnNsYXRlKHRleHQ6IHN0cmluZywgZnJvbTogbGFuZ0NvZGVXaXRoQXV0bywgdG86IGxhbmdDb2RlKSB7XG5cdFx0Y29uc3QgZnJlZSA9IGF3YWl0IHRoaXMuc2VtYWZvci50YWtlKCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRvci50cmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLmZpbmFsbHkoZnJlZSk7XG5cdH1cblxuXHRwcml2YXRlIHNwbGl0QW5kVHJhbnNsYXRlKFxuXHRcdHRleHQ6IHN0cmluZyxcblx0XHRmcm9tOiBsYW5nQ29kZVdpdGhBdXRvLFxuXHRcdHRvOiBsYW5nQ29kZSxcblx0XHRjb250ZXh0OiBzdHJpbmcsXG5cdFx0cHJpb3JpdHk6IG51bWJlcixcblx0KSB7XG5cdFx0Y29uc3Qgc3BsaXR0ZWRUZXh0OiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGNoYXJzZXRJbmRleGVzOiBudW1iZXJbXSA9IFtdO1xuXG5cdFx0bGV0IHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0Zm9yIChjb25zdCB0ZXh0TWF0Y2ggb2YgdGV4dC5tYXRjaEFsbCgvKFteXFxzXSspKFxccyopL2cpKSB7XG5cdFx0XHRjb25zdCBuZXdQYXJ0ID0gdGV4dE1hdGNoWzBdO1xuXHRcdFx0Y29uc3QgbmV3QnVmZmVyID0gd29yZHNCdWZmZXIgKyBuZXdQYXJ0O1xuXG5cdFx0XHQvLyBBZGQgd29yZCB0byBidWZmZXIgaWYgY2FuXG5cdFx0XHRpZiAodGhpcy50cmFuc2xhdG9yLmNoZWNrTGltaXRFeGNlZWRpbmcobmV3QnVmZmVyKSA8PSAwKSB7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JpdGUgYW5kIGNsZWFyIGJ1ZmZlciBpZiBub3QgZW1wdGh5XG5cdFx0XHRpZiAod29yZHNCdWZmZXIubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRzcGxpdHRlZFRleHQucHVzaCh3b3Jkc0J1ZmZlcik7XG5cdFx0XHRcdHdvcmRzQnVmZmVyID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBuZXcgcGFydFxuXHRcdFx0aWYgKHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKG5ld1BhcnQpIDw9IDApIHtcblx0XHRcdFx0Ly8gQWRkIHRvIGJ1ZmZlclxuXHRcdFx0XHR3b3Jkc0J1ZmZlciArPSBuZXdQYXJ0O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFNsaWNlIGJ5IGNoYXJzXG5cdFx0XHRcdGxldCBjaGFyc0J1ZmZlciA9IG5ld1BhcnQ7XG5cdFx0XHRcdHdoaWxlIChjaGFyc0J1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgZXh0cmFDaGFycyA9IHRoaXMudHJhbnNsYXRvci5jaGVja0xpbWl0RXhjZWVkaW5nKGNoYXJzQnVmZmVyKTtcblx0XHRcdFx0XHRpZiAoZXh0cmFDaGFycyA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IG9mZnNldCA9IGNoYXJzQnVmZmVyLmxlbmd0aCAtIGV4dHJhQ2hhcnM7XG5cblx0XHRcdFx0XHRcdC8vIFdyaXRlIHNsaWNlIGFuZCByZW1haW5kZXJcblx0XHRcdFx0XHRcdHNwbGl0dGVkVGV4dC5wdXNoKGNoYXJzQnVmZmVyLnNsaWNlKDAsIG9mZnNldCkpO1xuXHRcdFx0XHRcdFx0Y2hhcnNCdWZmZXIgPSBjaGFyc0J1ZmZlci5zbGljZShvZmZzZXQpO1xuXG5cdFx0XHRcdFx0XHRjaGFyc2V0SW5kZXhlcy5wdXNoKHNwbGl0dGVkVGV4dC5sZW5ndGggLSAxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBjdHhQcmVmaXggPSBjb250ZXh0Lmxlbmd0aCA+IDAgPyBjb250ZXh0ICsgJzsnIDogJyc7XG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFxuXHRcdFx0c3BsaXR0ZWRUZXh0Lm1hcCgodGV4dCwgaW5kZXgpID0+XG5cdFx0XHRcdGNoYXJzZXRJbmRleGVzLmluZGV4T2YoaW5kZXgpICE9PSAtMVxuXHRcdFx0XHRcdD8gdGV4dFxuXHRcdFx0XHRcdDogdGhpcy5tYWtlVGFzayh7XG5cdFx0XHRcdFx0XHR0ZXh0LFxuXHRcdFx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0XHRcdHRvLFxuXHRcdFx0XHRcdFx0Y29udGV4dDogY3R4UHJlZml4ICsgYHRleHQjJHt0aGlzLmNvbnRleHRDb3VudGVyKyt9YCxcblx0XHRcdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRcdCAgfSksXG5cdFx0XHQpLFxuXHRcdCkudGhlbigodHJhbnNsYXRlZFBhcnRzKSA9PiB0cmFuc2xhdGVkUGFydHMuam9pbignJykpO1xuXHR9XG5cblx0cHJpdmF0ZSBtYWtlVGFzayh7IHRleHQsIGZyb20sIHRvLCBwcmlvcml0eSwgY29udGV4dCA9ICcnIH06IFRhc2tDb25zdHJ1Y3Rvcikge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRcdHRoaXMuYWRkVG9UYXNrQ29udGFpbmVyKHtcblx0XHRcdFx0dGV4dCxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdGNvbnRleHQsXG5cdFx0XHRcdHByaW9yaXR5LFxuXHRcdFx0XHRyZXNvbHZlLFxuXHRcdFx0XHRyZWplY3QsXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgcmVhZG9ubHkgdGFza0NvbnRhaW5lcnNTdG9yYWdlID0gbmV3IFNldDxUYXNrQ29udGFpbmVyPigpO1xuXHRwcml2YXRlIGFkZFRvVGFza0NvbnRhaW5lcihwYXJhbXM6IFRhc2tDb25zdHJ1Y3RvckludGVybmFsKSB7XG5cdFx0Y29uc3Qge1xuXHRcdFx0dGV4dCxcblx0XHRcdGZyb20sXG5cdFx0XHR0byxcblx0XHRcdGF0dGVtcHQgPSAwLFxuXHRcdFx0Y29udGV4dCA9ICcnLFxuXHRcdFx0cHJpb3JpdHksXG5cdFx0XHRyZXNvbHZlLFxuXHRcdFx0cmVqZWN0LFxuXHRcdH0gPSBwYXJhbXM7XG5cblx0XHQvLyBjcmVhdGUgdGFza1xuXHRcdGNvbnN0IHRhc2s6IFRhc2sgPSB7XG5cdFx0XHR0ZXh0LFxuXHRcdFx0ZnJvbSxcblx0XHRcdHRvLFxuXHRcdFx0YXR0ZW1wdCxcblx0XHRcdHJlc29sdmUsXG5cdFx0XHRyZWplY3QsXG5cdFx0fTtcblxuXHRcdGxldCBjb250YWluZXI6IFRhc2tDb250YWluZXIgfCBudWxsID0gbnVsbDtcblxuXHRcdC8vIHRyeSBhZGQgdG8gZXhpc3RzIGNvbnRhaW5lclxuXHRcdGZvciAoY29uc3QgdGFza0NvbnRhaW5lciBvZiB0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZSkge1xuXHRcdFx0Ly8gU2tpcCBjb250YWluZXJzIHdpdGggbm90IGVxdWFsIHBhcmFtZXRlcnNcblx0XHRcdGlmIChcblx0XHRcdFx0Wydmcm9tJywgJ3RvJywgJ2NvbnRleHQnLCAncHJpb3JpdHknXS5zb21lKFxuXHRcdFx0XHRcdChrZXkpID0+IChwYXJhbXMgYXMgYW55KVtrZXldICE9PSAodGFza0NvbnRhaW5lciBhcyBhbnkpW2tleV0sXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHRcdFx0Y29udGludWU7XG5cblx0XHRcdC8vIExpZ2h0d2VpZ2h0IGNoZWNrIHRvIG92ZXJmbG93XG5cdFx0XHQvLyBOT1RFOiBEbyBzdHJpY3QgY2hlY2sgaGVyZSBpZiB5b3UgbmVlZCBjb21wbHkgYSBsaW1pdCBjb250cmFjdFxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLnRyYW5zbGF0b3IuZ2V0TGVuZ3RoTGltaXQoKSA+PVxuXHRcdFx0XHR0YXNrQ29udGFpbmVyLmxlbmd0aCArIHRhc2sudGV4dC5sZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0XHR0YXNrQ29udGFpbmVyLnRhc2tzLnB1c2godGFzayk7XG5cdFx0XHRcdHRhc2tDb250YWluZXIubGVuZ3RoICs9IHRhc2sudGV4dC5sZW5ndGg7XG5cdFx0XHRcdGNvbnRhaW5lciA9IHRhc2tDb250YWluZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gbWFrZSBjb250YWluZXJcblx0XHRpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG5cdFx0XHRjb25zdCBuZXdUYXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyID0ge1xuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdFx0ZnJvbSxcblx0XHRcdFx0dG8sXG5cdFx0XHRcdHRhc2tzOiBbdGFza10sXG5cdFx0XHRcdGxlbmd0aDogdGFzay50ZXh0Lmxlbmd0aCxcblx0XHRcdH07XG5cdFx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5hZGQobmV3VGFza0NvbnRhaW5lcik7XG5cdFx0XHRjb250YWluZXIgPSBuZXdUYXNrQ29udGFpbmVyO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdHRoaXMuY29uZmlnLmNodW5rU2l6ZUZvckluc3RhbnRUcmFuc2xhdGUgIT09IG51bGwgJiZcblx0XHRcdGNvbnRhaW5lci5sZW5ndGggPj0gdGhpcy5jb25maWcuY2h1bmtTaXplRm9ySW5zdGFudFRyYW5zbGF0ZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlRGVsYXlGb3JBZGRUb1RyYW5zbGF0ZVF1ZXVlKGNvbnRhaW5lcik7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSByZWFkb25seSB0aW1lcnNNYXAgPSBuZXcgTWFwPFRhc2tDb250YWluZXIsIG51bWJlciB8IE5vZGVKUy5UaW1lb3V0PigpO1xuXHRwcml2YXRlIHVwZGF0ZURlbGF5Rm9yQWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHR9XG5cblx0XHR0aGlzLnRpbWVyc01hcC5zZXQoXG5cdFx0XHR0YXNrQ29udGFpbmVyLFxuXHRcdFx0Z2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0dGhpcy5hZGRUb1RyYW5zbGF0ZVF1ZXVlKHRhc2tDb250YWluZXIpO1xuXHRcdFx0fSwgdGhpcy5jb25maWcudHJhbnNsYXRlUG9vbERlbGF5KSxcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRhc2tzIHF1ZXVlIHdpdGggaXRlbXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqIEl0IG11c3QgYmUgaGFuZGxlZCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKi9cblx0cHJpdmF0ZSB0cmFuc2xhdGVRdWV1ZTogVGFza0NvbnRhaW5lcltdID0gW107XG5cdHByaXZhdGUgYWRkVG9UcmFuc2xhdGVRdWV1ZSh0YXNrQ29udGFpbmVyOiBUYXNrQ29udGFpbmVyKSB7XG5cdFx0Ly8gRmx1c2ggdGltZXJcblx0XHRpZiAodGhpcy50aW1lcnNNYXAuaGFzKHRhc2tDb250YWluZXIpKSB7XG5cdFx0XHQvLyBEdWUgdG8gZXhwZWN0YXRpb24gcnVuIG9uIG9uZSBwbGF0Zm9ybSwgdGltZXIgb2JqZWN0cyB3aWxsIHNhbWUgYWx3YXlzXG5cdFx0XHRnbG9iYWxUaGlzLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyc01hcC5nZXQodGFza0NvbnRhaW5lcikgYXMgYW55KTtcblx0XHRcdHRoaXMudGltZXJzTWFwLmRlbGV0ZSh0YXNrQ29udGFpbmVyKTtcblx0XHR9XG5cblx0XHR0aGlzLnRhc2tDb250YWluZXJzU3RvcmFnZS5kZWxldGUodGFza0NvbnRhaW5lcik7XG5cblx0XHQvLyBSZXNvcnQgcXVldWUgYnkgcHJpb3JpdHkgZWFjaCB0aW1lIHRvIGtlZXAgY29uc2lzdGVuY3lcblx0XHR0aGlzLnRyYW5zbGF0ZVF1ZXVlID0gdGhpcy50cmFuc2xhdGVRdWV1ZVxuXHRcdFx0LmNvbmNhdCh0YXNrQ29udGFpbmVyKVxuXHRcdFx0LnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcblxuXHRcdGlmICghdGhpcy53b3JrZXJTdGF0ZSkge1xuXHRcdFx0dGhpcy5ydW5Xb3JrZXIoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIGZpcnN0IGl0ZW0gZnJvbSBxdWV1ZSBhbmQgZGVsZXRlIGl0IGZyb20gcXVldWVcblx0ICogSXRlbXMgaXMgc29ydGVkIGJ5IHByaW9yaXR5XG5cdCAqL1xuXHRwcml2YXRlIGdldEl0ZW1Gcm9tVHJhbnNsYXRlUXVldWUgPSAoKTogSXRlcmF0b3JTdGVwPFRhc2tDb250YWluZXI+ID0+IHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZG9uZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5sZW5ndGggPT09IDAsXG5cdFx0XHR2YWx1ZTogdGhpcy50cmFuc2xhdGVRdWV1ZS5wb3AoKSA/PyBudWxsLFxuXHRcdH07XG5cdH07XG5cblx0cHJpdmF0ZSB3b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHRwcml2YXRlIGFzeW5jIHJ1bldvcmtlcigpIHtcblx0XHR0aGlzLndvcmtlclN0YXRlID0gdHJ1ZTtcblxuXHRcdGxldCBmaXJzdEl0ZXJhdGlvbiA9IHRydWU7XG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdC8vIERlbGF5IGZpcnN0IGl0ZXJhdGlvbiB0byBhd2FpdCBmaWxsIHRoZSBxdWV1ZSwgdG8gY29uc2lkZXIgcHJpb3JpdHkgYmV0dGVyXG5cdFx0XHRjb25zdCB3b3JrZXJIYW5kbGVEZWxheSA9IHRoaXMuY29uZmlnLnRhc2tCYXRjaEhhbmRsZURlbGF5O1xuXHRcdFx0aWYgKHdvcmtlckhhbmRsZURlbGF5ICYmIGZpcnN0SXRlcmF0aW9uKSB7XG5cdFx0XHRcdGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCB3b3JrZXJIYW5kbGVEZWxheSkpO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdEl0ZXJhdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRjb25zdCBpdGVyYXRlID0gdGhpcy5nZXRJdGVtRnJvbVRyYW5zbGF0ZVF1ZXVlKCk7XG5cblx0XHRcdC8vIFNraXAgd2hlbiBxdWV1ZSBlbXB0eVxuXHRcdFx0aWYgKGl0ZXJhdGUuZG9uZSB8fCBpdGVyYXRlLnZhbHVlID09PSBudWxsKSBicmVhaztcblxuXHRcdFx0Y29uc3QgdGFza0NvbnRhaW5lciA9IGl0ZXJhdGUudmFsdWU7XG5cblx0XHRcdGNvbnN0IGZyZWUgPSBhd2FpdCB0aGlzLnNlbWFmb3IudGFrZSgpO1xuXG5cdFx0XHRjb25zdCB0ZXh0QXJyYXkgPSB0YXNrQ29udGFpbmVyLnRhc2tzLm1hcCgoaSkgPT4gaS50ZXh0KTtcblx0XHRcdGF3YWl0IHRoaXMudHJhbnNsYXRvclxuXHRcdFx0XHQudHJhbnNsYXRlQmF0Y2godGV4dEFycmF5LCB0YXNrQ29udGFpbmVyLmZyb20sIHRhc2tDb250YWluZXIudG8pXG5cdFx0XHRcdC50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IGluZGV4IGluIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHRhc2sgPSB0YXNrQ29udGFpbmVyLnRhc2tzW2luZGV4XTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNsYXRlZFRleHQgPSByZXN1bHRbaW5kZXhdO1xuXHRcdFx0XHRcdFx0aWYgKHRyYW5zbGF0ZWRUZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHRhc2sucmVzb2x2ZSh0cmFuc2xhdGVkVGV4dCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnRhc2tFcnJvckhhbmRsZXIoXG5cdFx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJUcmFuc2xhdG9yIG1vZHVsZSBjYW4ndCB0cmFuc2xhdGUgdGhpc1wiKSxcblx0XHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdFx0dGFza0NvbnRhaW5lci5wcmlvcml0eSxcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgocmVhc29uKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihyZWFzb24pO1xuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0YXNrIG9mIHRhc2tDb250YWluZXIudGFza3MpIHtcblx0XHRcdFx0XHRcdHRoaXMudGFza0Vycm9ySGFuZGxlcihcblx0XHRcdFx0XHRcdFx0dGFzayxcblx0XHRcdFx0XHRcdFx0cmVhc29uLFxuXHRcdFx0XHRcdFx0XHR0YXNrQ29udGFpbmVyLmNvbnRleHQsXG5cdFx0XHRcdFx0XHRcdHRhc2tDb250YWluZXIucHJpb3JpdHksXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0LmZpbmFsbHkoZnJlZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy53b3JrZXJTdGF0ZSA9IGZhbHNlO1xuXHR9XG5cblx0cHJpdmF0ZSB0YXNrRXJyb3JIYW5kbGVyKHRhc2s6IFRhc2ssIGVycm9yOiBhbnksIGNvbnRleHQ6IHN0cmluZywgcHJpb3JpdHk6IG51bWJlcikge1xuXHRcdGlmICh0YXNrLmF0dGVtcHQgPj0gdGhpcy5jb25maWcudHJhbnNsYXRlUmV0cnlBdHRlbXB0TGltaXQpIHtcblx0XHRcdGlmICh0aGlzLmNvbmZpZy5pc0FsbG93RGlyZWN0VHJhbnNsYXRlQmFkQ2h1bmtzKSB7XG5cdFx0XHRcdGNvbnN0IHsgdGV4dCwgZnJvbSwgdG8sIHJlc29sdmUsIHJlamVjdCB9ID0gdGFzaztcblx0XHRcdFx0dGhpcy5kaXJlY3RUcmFuc2xhdGUodGV4dCwgZnJvbSwgdG8pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhc2sucmVqZWN0KGVycm9yKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5hZGRUb1Rhc2tDb250YWluZXIoe1xuXHRcdFx0XHQuLi50YXNrLFxuXHRcdFx0XHRhdHRlbXB0OiB0YXNrLmF0dGVtcHQgKyAxLFxuXHRcdFx0XHRjb250ZXh0LFxuXHRcdFx0XHRwcmlvcml0eSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFNQSxJQUFBQSxVQUFBLEdBQUFDLE9BQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyR0E7Ozs7Ozs7QUFPQSxJQUFBQyxTQUFBLEdBQUFDLE9BQUEsQ0FBQUQsU0FBQTtFQVlDLFNBQUFBLFVBQVlFLFVBQXFDLEVBQUVDLE1BQXdCO0lBQTNFLElBQUFDLEtBQUE7SUFUaUIsS0FBQUQsTUFBTSxHQUE4QjtNQUNwREUsMEJBQTBCLEVBQUUsQ0FBQztNQUM3QkMsK0JBQStCLEVBQUUsSUFBSTtNQUNyQ0MscUJBQXFCLEVBQUUsSUFBSTtNQUMzQkMsa0JBQWtCLEVBQUUsR0FBRztNQUN2QkMsNEJBQTRCLEVBQUUsSUFBSTtNQUNsQ0Msb0JBQW9CLEVBQUU7S0FDdEI7SUFjTyxLQUFBQyxjQUFjLEdBQUcsQ0FBQztJQW1IVCxLQUFBQyxxQkFBcUIsR0FBRyxJQUFJQyxHQUFHLEVBQWlCO0lBdUVoRCxLQUFBQyxTQUFTLEdBQUcsSUFBSUMsR0FBRyxFQUEwQztJQWdCOUU7Ozs7SUFJUSxLQUFBQyxjQUFjLEdBQW9CLEVBQUU7SUFxQjVDOzs7O0lBSVEsS0FBQUMseUJBQXlCLEdBQUc7O01BQ25DLE9BQU87UUFDTkMsSUFBSSxFQUFFZCxLQUFJLENBQUNZLGNBQWMsQ0FBQ0csTUFBTSxLQUFLLENBQUM7UUFDdENDLEtBQUssRUFBRSxDQUFBQyxFQUFBLEdBQUFqQixLQUFJLENBQUNZLGNBQWMsQ0FBQ00sR0FBRyxFQUFFLGNBQUFELEVBQUEsY0FBQUEsRUFBQSxHQUFJO09BQ3BDO0lBQ0YsQ0FBQztJQUVPLEtBQUFFLFdBQVcsR0FBRyxLQUFLO0lBelAxQixJQUFJLENBQUNyQixVQUFVLEdBQUdBLFVBQVU7SUFFNUIsSUFBSUMsTUFBTSxLQUFLcUIsU0FBUyxFQUFFO01BQ3pCLEtBQUssSUFBTUMsR0FBRyxJQUFJdEIsTUFBTSxFQUFFO1FBQ3hCLElBQUksQ0FBQ0EsTUFBYyxDQUFDc0IsR0FBRyxDQUFDLEdBQUl0QixNQUFjLENBQUNzQixHQUFHLENBQUM7OztJQUlsRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJQyxvQkFBUyxDQUFDO01BQUVDLE9BQU8sRUFBRTFCLFVBQVUsQ0FBQzJCLGtCQUFrQjtJQUFFLENBQUUsQ0FBQztFQUMzRTtFQUdhN0IsU0FBQSxDQUFBOEIsU0FBQSxDQUFBQyxTQUFTLEdBQXRCLFVBQ0NDLElBQVksRUFDWkMsSUFBc0IsRUFDdEJDLEVBQVksRUFDWkMsT0FBb0M7Ozs7UUFFOUJkLEVBQUEsR0FJRmMsT0FBTyxLQUFLWCxTQUFTLEdBQUdXLE9BQU8sR0FBRyxFQUFFLEVBSHZDQyxFQUFBLEdBQUFmLEVBQUEsQ0FBQWdCLE9BQVksRUFBWkEsT0FBTyxHQUFBRCxFQUFBLGNBQUcsRUFBRSxHQUFBQSxFQUFBLEVBQ1pFLEVBQUEsR0FBQWpCLEVBQUEsQ0FBQWtCLFFBQVksRUFBWkEsUUFBUSxHQUFBRCxFQUFBLGNBQUcsQ0FBQyxHQUFBQSxFQUFBLEVBQ1pFLEVBQUEsR0FBQW5CLEVBQUEsQ0FBQW9CLGVBQXNELEVBQXJDQyw2QkFBNkIsR0FBQUYsRUFBQSxjQUFHLEtBQUssR0FBQUEsRUFBQTtRQUd2RCxJQUFJLElBQUksQ0FBQ3RDLFVBQVUsQ0FBQ3lDLG1CQUFtQixDQUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7VUFDbkQ7VUFDQSxJQUNDVSw2QkFBNkIsSUFDNUIsSUFBSSxDQUFDdkMsTUFBTSxDQUFDSSxxQkFBcUIsS0FBSyxJQUFJLElBQzFDeUIsSUFBSSxDQUFDYixNQUFNLElBQUksSUFBSSxDQUFDaEIsTUFBTSxDQUFDSSxxQkFBc0IsRUFDakQ7WUFDRCxzQkFBTyxJQUFJLENBQUNrQyxlQUFlLENBQUNULElBQUksRUFBRUMsSUFBSSxFQUFFQyxFQUFFLENBQUM7V0FDM0MsTUFBTTtZQUNOLHNCQUFPLElBQUksQ0FBQ1UsUUFBUSxDQUFDO2NBQUVaLElBQUksRUFBRUEsSUFBSTtjQUFFQyxJQUFJLEVBQUFBLElBQUE7Y0FBRUMsRUFBRSxFQUFBQSxFQUFBO2NBQUVHLE9BQU8sRUFBQUEsT0FBQTtjQUFFRSxRQUFRLEVBQUFBO1lBQUEsQ0FBRSxDQUFDOztTQUVsRSxNQUFNO1VBQ047VUFDQSxzQkFBTyxJQUFJLENBQUNNLGlCQUFpQixDQUFDYixJQUFJLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFFRyxPQUFPLEVBQUVFLFFBQVEsQ0FBQzs7Ozs7R0FFakU7RUFFYXZDLFNBQUEsQ0FBQThCLFNBQUEsQ0FBQVcsZUFBZSxHQUE3QixVQUE4QlQsSUFBWSxFQUFFQyxJQUFzQixFQUFFQyxFQUFZOzs7Ozs7WUFDbEUscUJBQU0sSUFBSSxDQUFDUixPQUFPLENBQUNvQixJQUFJLEVBQUU7O1lBQWhDQyxJQUFJLEdBQUcxQixFQUFBLENBQUEyQixJQUFBLEVBQXlCO1lBQ3RDLHNCQUFPLElBQUksQ0FBQzlDLFVBQVUsQ0FBQzZCLFNBQVMsQ0FBQ0MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsQ0FBQyxDQUFDZSxPQUFPLENBQUNGLElBQUksQ0FBQzs7OztHQUM5RDtFQUVPL0MsU0FBQSxDQUFBOEIsU0FBQSxDQUFBZSxpQkFBaUIsR0FBekIsVUFDQ2IsSUFBWSxFQUNaQyxJQUFzQixFQUN0QkMsRUFBWSxFQUNaRyxPQUFlLEVBQ2ZFLFFBQWdCOztJQUxqQixJQUFBbkMsS0FBQTtJQU9DLElBQU04QyxZQUFZLEdBQWEsRUFBRTtJQUNqQyxJQUFNQyxjQUFjLEdBQWEsRUFBRTtJQUVuQyxJQUFJQyxXQUFXLEdBQUcsRUFBRTs7TUFDcEIsS0FBd0IsSUFBQWhCLEVBQUEsR0FBQWlCLFFBQUEsQ0FBQXJCLElBQUksQ0FBQ3NCLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFBaEIsRUFBQSxHQUFBRixFQUFBLENBQUFtQixJQUFBLEtBQUFqQixFQUFBLENBQUFwQixJQUFBLEVBQUFvQixFQUFBLEdBQUFGLEVBQUEsQ0FBQW1CLElBQUEsSUFBRTtRQUFwRCxJQUFNQyxTQUFTLEdBQUFsQixFQUFBLENBQUFsQixLQUFBO1FBQ25CLElBQU1xQyxPQUFPLEdBQUdELFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDNUIsSUFBTUUsU0FBUyxHQUFHTixXQUFXLEdBQUdLLE9BQU87UUFFdkM7UUFDQSxJQUFJLElBQUksQ0FBQ3ZELFVBQVUsQ0FBQ3lDLG1CQUFtQixDQUFDZSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7VUFDeEROLFdBQVcsR0FBR00sU0FBUztVQUN2Qjs7UUFHRDtRQUNBLElBQUlOLFdBQVcsQ0FBQ2pDLE1BQU0sR0FBRyxDQUFDLEVBQUU7VUFDM0IrQixZQUFZLENBQUNTLElBQUksQ0FBQ1AsV0FBVyxDQUFDO1VBQzlCQSxXQUFXLEdBQUcsRUFBRTs7UUFHakI7UUFDQSxJQUFJLElBQUksQ0FBQ2xELFVBQVUsQ0FBQ3lDLG1CQUFtQixDQUFDYyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUU7VUFDdEQ7VUFDQUwsV0FBVyxJQUFJSyxPQUFPO1VBQ3RCO1NBQ0EsTUFBTTtVQUNOO1VBQ0EsSUFBSUcsV0FBVyxHQUFHSCxPQUFPO1VBQ3pCLE9BQU9HLFdBQVcsQ0FBQ3pDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDOUIsSUFBTTBDLFVBQVUsR0FBRyxJQUFJLENBQUMzRCxVQUFVLENBQUN5QyxtQkFBbUIsQ0FBQ2lCLFdBQVcsQ0FBQztZQUNuRSxJQUFJQyxVQUFVLEdBQUcsQ0FBQyxFQUFFO2NBQ25CLElBQU1DLE1BQU0sR0FBR0YsV0FBVyxDQUFDekMsTUFBTSxHQUFHMEMsVUFBVTtjQUU5QztjQUNBWCxZQUFZLENBQUNTLElBQUksQ0FBQ0MsV0FBVyxDQUFDRyxLQUFLLENBQUMsQ0FBQyxFQUFFRCxNQUFNLENBQUMsQ0FBQztjQUMvQ0YsV0FBVyxHQUFHQSxXQUFXLENBQUNHLEtBQUssQ0FBQ0QsTUFBTSxDQUFDO2NBRXZDWCxjQUFjLENBQUNRLElBQUksQ0FBQ1QsWUFBWSxDQUFDL0IsTUFBTSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztJQU1oRCxJQUFNNkMsU0FBUyxHQUFHM0IsT0FBTyxDQUFDbEIsTUFBTSxHQUFHLENBQUMsR0FBR2tCLE9BQU8sR0FBRyxHQUFHLEdBQUcsRUFBRTtJQUN6RCxPQUFPNEIsT0FBTyxDQUFDQyxHQUFHLENBQ2pCaEIsWUFBWSxDQUFDaUIsR0FBRyxDQUFDLFVBQUNuQyxJQUFJLEVBQUVvQyxLQUFLO01BQzVCLE9BQUFqQixjQUFjLENBQUNrQixPQUFPLENBQUNELEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUNqQ3BDLElBQUksR0FDSjVCLEtBQUksQ0FBQ3dDLFFBQVEsQ0FBQztRQUNmWixJQUFJLEVBQUFBLElBQUE7UUFDSkMsSUFBSSxFQUFBQSxJQUFBO1FBQ0pDLEVBQUUsRUFBQUEsRUFBQTtRQUNGRyxPQUFPLEVBQUUyQixTQUFTLEdBQUcsUUFBQU0sTUFBQSxDQUFRbEUsS0FBSSxDQUFDTyxjQUFjLEVBQUUsQ0FBRTtRQUNwRDRCLFFBQVEsRUFBQUE7T0FDTixDQUFDO0lBUkwsQ0FRSyxDQUNMLENBQ0QsQ0FBQ2dDLElBQUksQ0FBQyxVQUFDQyxlQUFlO01BQUssT0FBQUEsZUFBZSxDQUFDQyxJQUFJLENBQUMsRUFBRSxDQUFDO0lBQXhCLENBQXdCLENBQUM7RUFDdEQsQ0FBQztFQUVPekUsU0FBQSxDQUFBOEIsU0FBQSxDQUFBYyxRQUFRLEdBQWhCLFVBQWlCdkIsRUFBMkQ7SUFBNUUsSUFBQWpCLEtBQUE7UUFBbUI0QixJQUFJLEdBQUFYLEVBQUEsQ0FBQVcsSUFBQTtNQUFFQyxJQUFJLEdBQUFaLEVBQUEsQ0FBQVksSUFBQTtNQUFFQyxFQUFFLEdBQUFiLEVBQUEsQ0FBQWEsRUFBQTtNQUFFSyxRQUFRLEdBQUFsQixFQUFBLENBQUFrQixRQUFBO01BQUVILEVBQUEsR0FBQWYsRUFBQSxDQUFBZ0IsT0FBWTtNQUFaQSxPQUFPLEdBQUFELEVBQUEsY0FBRyxFQUFFLEdBQUFBLEVBQUE7SUFDeEQsT0FBTyxJQUFJNkIsT0FBTyxDQUFTLFVBQUNTLE9BQU8sRUFBRUMsTUFBTTtNQUMxQ3ZFLEtBQUksQ0FBQ3dFLGtCQUFrQixDQUFDO1FBQ3ZCNUMsSUFBSSxFQUFBQSxJQUFBO1FBQ0pDLElBQUksRUFBQUEsSUFBQTtRQUNKQyxFQUFFLEVBQUFBLEVBQUE7UUFDRkcsT0FBTyxFQUFBQSxPQUFBO1FBQ1BFLFFBQVEsRUFBQUEsUUFBQTtRQUNSbUMsT0FBTyxFQUFBQSxPQUFBO1FBQ1BDLE1BQU0sRUFBQUE7T0FDTixDQUFDO0lBQ0gsQ0FBQyxDQUFDO0VBQ0gsQ0FBQztFQUdPM0UsU0FBQSxDQUFBOEIsU0FBQSxDQUFBOEMsa0JBQWtCLEdBQTFCLFVBQTJCQyxNQUErQjs7SUFFeEQsSUFBQTdDLElBQUksR0FRRDZDLE1BQU0sQ0FBQTdDLElBUkw7TUFDSkMsSUFBSSxHQU9ENEMsTUFBTSxDQUFBNUMsSUFQTDtNQUNKQyxFQUFFLEdBTUMyQyxNQUFNLENBQUEzQyxFQU5QO01BQ0ZFLEVBQUEsR0FLR3lDLE1BQU0sQ0FBQUMsT0FMRTtNQUFYQSxPQUFPLEdBQUExQyxFQUFBLGNBQUcsQ0FBQyxHQUFBQSxFQUFBO01BQ1hFLEVBQUEsR0FJR3VDLE1BQU0sQ0FBQXhDLE9BSkc7TUFBWkEsT0FBTyxHQUFBQyxFQUFBLGNBQUcsRUFBRSxHQUFBQSxFQUFBO01BQ1pDLFFBQVEsR0FHTHNDLE1BQU0sQ0FBQXRDLFFBSEQ7TUFDUm1DLE9BQU8sR0FFSkcsTUFBTSxDQUFBSCxPQUZGO01BQ1BDLE1BQU0sR0FDSEUsTUFBTSxDQUFBRixNQURIO0lBR1A7SUFDQSxJQUFNSSxJQUFJLEdBQVM7TUFDbEIvQyxJQUFJLEVBQUFBLElBQUE7TUFDSkMsSUFBSSxFQUFBQSxJQUFBO01BQ0pDLEVBQUUsRUFBQUEsRUFBQTtNQUNGNEMsT0FBTyxFQUFBQSxPQUFBO01BQ1BKLE9BQU8sRUFBQUEsT0FBQTtNQUNQQyxNQUFNLEVBQUFBO0tBQ047SUFFRCxJQUFJSyxTQUFTLEdBQXlCLElBQUk7NEJBRy9CQyxhQUFhO01BQ3ZCO01BQ0EsSUFDQyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQyxDQUFDQyxJQUFJLENBQ3pDLFVBQUN6RCxHQUFHO1FBQUssT0FBQ29ELE1BQWMsQ0FBQ3BELEdBQUcsQ0FBQyxLQUFNd0QsYUFBcUIsQ0FBQ3hELEdBQUcsQ0FBQztNQUFwRCxDQUFvRCxDQUM3RCxFO01BSUY7TUFDQTtNQUNBLElBQ0MwRCxNQUFBLENBQUtqRixVQUFVLENBQUNrRixjQUFjLEVBQUUsSUFDaENILGFBQWEsQ0FBQzlELE1BQU0sR0FBRzRELElBQUksQ0FBQy9DLElBQUksQ0FBQ2IsTUFBTSxFQUN0QztRQUNEOEQsYUFBYSxDQUFDSSxLQUFLLENBQUMxQixJQUFJLENBQUNvQixJQUFJLENBQUM7UUFDOUJFLGFBQWEsQ0FBQzlELE1BQU0sSUFBSTRELElBQUksQ0FBQy9DLElBQUksQ0FBQ2IsTUFBTTtRQUN4QzZELFNBQVMsR0FBR0MsYUFBYTs7Ozs7TUFsQjNCO01BQ0EsS0FBNEIsSUFBQXpDLEVBQUEsR0FBQWEsUUFBQSxLQUFJLENBQUN6QyxxQkFBcUIsR0FBQTBFLEVBQUEsR0FBQTlDLEVBQUEsQ0FBQWUsSUFBQSxLQUFBK0IsRUFBQSxDQUFBcEUsSUFBQSxFQUFBb0UsRUFBQSxHQUFBOUMsRUFBQSxDQUFBZSxJQUFBO1FBQWpELElBQU0wQixhQUFhLEdBQUFLLEVBQUEsQ0FBQWxFLEtBQUE7Z0JBQWI2RCxhQUFhOzs7Ozs7Ozs7Ozs7O0lBcUJ4QjtJQUNBLElBQUlELFNBQVMsS0FBSyxJQUFJLEVBQUU7TUFDdkIsSUFBTU8sZ0JBQWdCLEdBQWtCO1FBQ3ZDbEQsT0FBTyxFQUFBQSxPQUFBO1FBQ1BFLFFBQVEsRUFBQUEsUUFBQTtRQUNSTixJQUFJLEVBQUFBLElBQUE7UUFDSkMsRUFBRSxFQUFBQSxFQUFBO1FBQ0ZtRCxLQUFLLEVBQUUsQ0FBQ04sSUFBSSxDQUFDO1FBQ2I1RCxNQUFNLEVBQUU0RCxJQUFJLENBQUMvQyxJQUFJLENBQUNiO09BQ2xCO01BQ0QsSUFBSSxDQUFDUCxxQkFBcUIsQ0FBQzRFLEdBQUcsQ0FBQ0QsZ0JBQWdCLENBQUM7TUFDaERQLFNBQVMsR0FBR08sZ0JBQWdCOztJQUc3QixJQUNDLElBQUksQ0FBQ3BGLE1BQU0sQ0FBQ00sNEJBQTRCLEtBQUssSUFBSSxJQUNqRHVFLFNBQVMsQ0FBQzdELE1BQU0sSUFBSSxJQUFJLENBQUNoQixNQUFNLENBQUNNLDRCQUE0QixFQUMzRDtNQUNELElBQUksQ0FBQ2dGLG1CQUFtQixDQUFDVCxTQUFTLENBQUM7S0FDbkMsTUFBTTtNQUNOLElBQUksQ0FBQ1UsaUNBQWlDLENBQUNWLFNBQVMsQ0FBQzs7RUFFbkQsQ0FBQztFQUdPaEYsU0FBQSxDQUFBOEIsU0FBQSxDQUFBNEQsaUNBQWlDLEdBQXpDLFVBQTBDVCxhQUE0QjtJQUF0RSxJQUFBN0UsS0FBQTtJQUNDO0lBQ0EsSUFBSSxJQUFJLENBQUNVLFNBQVMsQ0FBQzZFLEdBQUcsQ0FBQ1YsYUFBYSxDQUFDLEVBQUU7TUFDdEM7TUFDQVcsVUFBVSxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDL0UsU0FBUyxDQUFDZ0YsR0FBRyxDQUFDYixhQUFhLENBQVEsQ0FBQzs7SUFHbEUsSUFBSSxDQUFDbkUsU0FBUyxDQUFDaUYsR0FBRyxDQUNqQmQsYUFBYSxFQUNiVyxVQUFVLENBQUNJLFVBQVUsQ0FBQztNQUNyQjVGLEtBQUksQ0FBQ3FGLG1CQUFtQixDQUFDUixhQUFhLENBQUM7SUFDeEMsQ0FBQyxFQUFFLElBQUksQ0FBQzlFLE1BQU0sQ0FBQ0ssa0JBQWtCLENBQUMsQ0FDbEM7RUFDRixDQUFDO0VBT09SLFNBQUEsQ0FBQThCLFNBQUEsQ0FBQTJELG1CQUFtQixHQUEzQixVQUE0QlIsYUFBNEI7SUFDdkQ7SUFDQSxJQUFJLElBQUksQ0FBQ25FLFNBQVMsQ0FBQzZFLEdBQUcsQ0FBQ1YsYUFBYSxDQUFDLEVBQUU7TUFDdEM7TUFDQVcsVUFBVSxDQUFDQyxZQUFZLENBQUMsSUFBSSxDQUFDL0UsU0FBUyxDQUFDZ0YsR0FBRyxDQUFDYixhQUFhLENBQVEsQ0FBQztNQUNqRSxJQUFJLENBQUNuRSxTQUFTLENBQUNtRixNQUFNLENBQUNoQixhQUFhLENBQUM7O0lBR3JDLElBQUksQ0FBQ3JFLHFCQUFxQixDQUFDcUYsTUFBTSxDQUFDaEIsYUFBYSxDQUFDO0lBRWhEO0lBQ0EsSUFBSSxDQUFDakUsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUN2Q3NELE1BQU0sQ0FBQ1csYUFBYSxDQUFDLENBQ3JCaUIsSUFBSSxDQUFDLFVBQUNDLENBQUMsRUFBRUMsQ0FBQztNQUFLLE9BQUFELENBQUMsQ0FBQzVELFFBQVEsR0FBRzZELENBQUMsQ0FBQzdELFFBQVE7SUFBdkIsQ0FBdUIsQ0FBQztJQUV6QyxJQUFJLENBQUMsSUFBSSxDQUFDaEIsV0FBVyxFQUFFO01BQ3RCLElBQUksQ0FBQzhFLFNBQVMsRUFBRTs7RUFFbEIsQ0FBQztFQWNhckcsU0FBQSxDQUFBOEIsU0FBQSxDQUFBdUUsU0FBUyxHQUF2Qjs7Ozs7OztZQUNDLElBQUksQ0FBQzlFLFdBQVcsR0FBRyxJQUFJO1lBRW5CK0UsY0FBYyxHQUFHLElBQUk7Ozs7OztvQkFHbEJDLGlCQUFpQixHQUFHQyxNQUFBLENBQUtyRyxNQUFNLENBQUNPLG9CQUFvQjswQkFDdEQ2RixpQkFBaUIsSUFBSUQsY0FBYyxHQUFuQztvQkFDSCxxQkFBTSxJQUFJckMsT0FBTyxDQUFDLFVBQUN3QyxHQUFHO3NCQUFLLE9BQUFULFVBQVUsQ0FBQ1MsR0FBRyxFQUFFRixpQkFBaUIsQ0FBQztvQkFBbEMsQ0FBa0MsQ0FBQzs7b0JBQTlEbkUsRUFBQSxDQUFBWSxJQUFBLEVBQThEOzs7b0JBRy9Ec0QsY0FBYyxHQUFHLEtBQUs7b0JBRWhCSSxPQUFPLEdBQUdGLE1BQUEsQ0FBS3ZGLHlCQUF5QixFQUFFO29CQUVoRDtvQkFDQSxJQUFJeUYsT0FBTyxDQUFDeEYsSUFBSSxJQUFJd0YsT0FBTyxDQUFDdEYsS0FBSyxLQUFLLElBQUksRTtvQkFFcEM2RCxhQUFhLEdBQUd5QixPQUFPLENBQUN0RixLQUFLO29CQUV0QixxQkFBTW9GLE1BQUEsQ0FBSzlFLE9BQU8sQ0FBQ29CLElBQUksRUFBRTs7b0JBQWhDQyxJQUFJLEdBQUdYLEVBQUEsQ0FBQVksSUFBQSxFQUF5QjtvQkFFaEMyRCxTQUFTLEdBQUcxQixhQUFhLENBQUNJLEtBQUssQ0FBQ2xCLEdBQUcsQ0FBQyxVQUFDeUMsQ0FBQztzQkFBSyxPQUFBQSxDQUFDLENBQUM1RSxJQUFJO29CQUFOLENBQU0sQ0FBQztvQkFDeEQscUJBQU13RSxNQUFBLENBQUt0RyxVQUFVLENBQ25CMkcsY0FBYyxDQUFDRixTQUFTLEVBQUUxQixhQUFhLENBQUNoRCxJQUFJLEVBQUVnRCxhQUFhLENBQUMvQyxFQUFFLENBQUMsQ0FDL0RxQyxJQUFJLENBQUMsVUFBQ3VDLE1BQU07c0JBQ1osS0FBSyxJQUFNMUMsS0FBSyxJQUFJYSxhQUFhLENBQUNJLEtBQUssRUFBRTt3QkFDeEMsSUFBTU4sSUFBSSxHQUFHRSxhQUFhLENBQUNJLEtBQUssQ0FBQ2pCLEtBQUssQ0FBQzt3QkFFdkMsSUFBTTJDLGNBQWMsR0FBR0QsTUFBTSxDQUFDMUMsS0FBSyxDQUFDO3dCQUNwQyxJQUFJMkMsY0FBYyxLQUFLLElBQUksRUFBRTswQkFDNUJoQyxJQUFJLENBQUNMLE9BQU8sQ0FBQ3FDLGNBQWMsQ0FBQzt5QkFDNUIsTUFBTTswQkFDTjNHLEtBQUksQ0FBQzRHLGdCQUFnQixDQUNwQmpDLElBQUksRUFDSixJQUFJa0MsS0FBSyxDQUFDLHdDQUF3QyxDQUFDLEVBQ25EaEMsYUFBYSxDQUFDNUMsT0FBTyxFQUNyQjRDLGFBQWEsQ0FBQzFDLFFBQVEsQ0FDdEI7OztvQkFHSixDQUFDLENBQUMsQ0FDRDJFLEtBQUssQ0FBQyxVQUFDQyxNQUFNOztzQkFDYkMsT0FBTyxDQUFDQyxLQUFLLENBQUNGLE1BQU0sQ0FBQzs7d0JBRXJCLEtBQW1CLElBQUEvRSxFQUFBLElBQUFrRixHQUFBLFdBQUFqRSxRQUFBLENBQUE0QixhQUFhLENBQUNJLEtBQUssSUFBQS9DLEVBQUEsR0FBQUYsRUFBQSxDQUFBbUIsSUFBQSxLQUFBakIsRUFBQSxDQUFBcEIsSUFBQSxFQUFBb0IsRUFBQSxHQUFBRixFQUFBLENBQUFtQixJQUFBLElBQUU7MEJBQW5DLElBQU13QixJQUFJLEdBQUF6QyxFQUFBLENBQUFsQixLQUFBOzBCQUNkaEIsS0FBSSxDQUFDNEcsZ0JBQWdCLENBQ3BCakMsSUFBSSxFQUNKb0MsTUFBTSxFQUNObEMsYUFBYSxDQUFDNUMsT0FBTyxFQUNyQjRDLGFBQWEsQ0FBQzFDLFFBQVEsQ0FDdEI7Ozs7Ozs7Ozs7Ozs7b0JBRUgsQ0FBQyxDQUFDLENBQ0RVLE9BQU8sQ0FBQ0YsSUFBSSxDQUFDOztvQkEvQmZYLEVBQUEsQ0FBQVksSUFBQSxFQStCZTs7Ozs7Ozs7aUJBbERULElBQUk7Ozs7Ozs7WUFxRFgsSUFBSSxDQUFDekIsV0FBVyxHQUFHLEtBQUs7Ozs7O0dBQ3hCO0VBRU92QixTQUFBLENBQUE4QixTQUFBLENBQUFrRixnQkFBZ0IsR0FBeEIsVUFBeUJqQyxJQUFVLEVBQUVzQyxLQUFVLEVBQUVoRixPQUFlLEVBQUVFLFFBQWdCO0lBQ2pGLElBQUl3QyxJQUFJLENBQUNELE9BQU8sSUFBSSxJQUFJLENBQUMzRSxNQUFNLENBQUNFLDBCQUEwQixFQUFFO01BQzNELElBQUksSUFBSSxDQUFDRixNQUFNLENBQUNHLCtCQUErQixFQUFFO1FBQ3hDLElBQUEwQixJQUFJLEdBQWdDK0MsSUFBSSxDQUFBL0MsSUFBcEM7VUFBRUMsSUFBSSxHQUEwQjhDLElBQUksQ0FBQTlDLElBQTlCO1VBQUVDLEVBQUUsR0FBc0I2QyxJQUFJLENBQUE3QyxFQUExQjtVQUFFd0MsT0FBTyxHQUFhSyxJQUFJLENBQUFMLE9BQWpCO1VBQUVDLE1BQU0sR0FBS0ksSUFBSSxDQUFBSixNQUFUO1FBQ3ZDLElBQUksQ0FBQ2xDLGVBQWUsQ0FBQ1QsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsQ0FBQyxDQUFDcUMsSUFBSSxDQUFDRyxPQUFPLEVBQUVDLE1BQU0sQ0FBQztPQUMxRCxNQUFNO1FBQ05JLElBQUksQ0FBQ0osTUFBTSxDQUFDMEMsS0FBSyxDQUFDOztLQUVuQixNQUFNO01BQ04sSUFBSSxDQUFDekMsa0JBQWtCLENBQUEyQyxRQUFBLENBQUFBLFFBQUEsS0FDbkJ4QyxJQUFJO1FBQ1BELE9BQU8sRUFBRUMsSUFBSSxDQUFDRCxPQUFPLEdBQUcsQ0FBQztRQUN6QnpDLE9BQU8sRUFBQUEsT0FBQTtRQUNQRSxRQUFRLEVBQUFBO01BQUEsR0FDUDs7RUFFSixDQUFDO0VBQ0YsT0FBQXZDLFNBQUM7QUFBRCxDQXBWQSxDQW9WQyIsImlnbm9yZUxpc3QiOltdfQ==
